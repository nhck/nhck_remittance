pragma solidity 0.5.8;

import './SafeMath.sol';
import './Stoppable.sol';

/**
 * @title Remittance of Alice' ethereum for the Blockstars course.
 */
contract Remittance is Stoppable {
    using SafeMath for uint;

    event LogWithdrawn(address indexed sender, uint amount, bytes32 retrievalCodeSecure);
    event LogDeposited(address indexed sender, uint amount, uint expiresTimestamp, bytes32 retrievalCodeSecure);
    event LogDepositReclaimed(address indexed sender, uint amount, bytes32 retrievalCodeSecure);
    event LogTimestampExtended(address indexed sender, uint expiresTimestamp, bytes32 retrievalCodeSecure);
    event LogTimestampShortend(address indexed sender, uint expiresTimestamp, bytes32 retrievalCodeSecure);

    struct Payment {
        address sender;
        uint amount;
        uint expiresTimestamp;
    }

    mapping(bytes32 => Payment) public payments;

    uint expiryLimit;

    constructor(bool startRunning, uint setExpiryLimit) Stoppable(startRunning) public {
        expiryLimit = setExpiryLimit;
    }

    /**
     * Allows to create a retrieval Code for the exchange locally
     */
    function createRetrievalCode(string memory plainCode) public pure returns (bytes32 retrievalCode) {
        return keccak256(abi.encodePacked(plainCode));
    }

    /**
     * Allows to create a retrieval Code for the sender locally
     * @param retrievalCode byte32 code generated by createRetrievalCode()
     * @param exchange adress of the recieving exchange
     */
    function createRetrievalCodeSecure(bytes32 retrievalCode, address exchange) public pure returns (bytes32 retrievalCodeSecure) {
        return keccak256(abi.encodePacked(exchange, retrievalCode));
    }

    /**
     * Allows deposit for a retrievalCodeSecure
     *
     * @param retrievalCodeSecure - a double keccak256 hash generated locally using two string parts and the target address
     *
     * @return true on success
     */
    function deposit(bytes32 retrievalCodeSecure, uint expiresTimestamp) onlyIfRunning public payable returns (bool success) {
        require(msg.value > 0, "Please send value to this contract");
        require(retrievalCodeSecure > 0, "Retrieval code needs to be provided");
        require(payments[retrievalCodeSecure].amount == 0, "Retrieval code already in use");
        require(expiresTimestamp > block.timestamp, "Expiry Timestamp should be greater than now");
        require(expiresTimestamp <= block.timestamp.add(expiryLimit), "Expiry Timestamp too far in the future");

        payments[retrievalCodeSecure] = Payment({sender : msg.sender, amount : msg.value, expiresTimestamp : expiresTimestamp});

        emit LogDeposited(msg.sender, msg.value, expiresTimestamp, retrievalCodeSecure);

        return true;
    }

    /**
     * Allows withdrawal by providing to parts of the retrievalCode
     *
     * @param retrievalCode  keccak256 hash generated locally and provided by the sender
     *
     * @return bool true on success
     */
    function withdraw(bytes32 retrievalCode) beyondEndOfLifeOrOnlyIfRunning public returns (bool success) {
        require(retrievalCode > 0, "Retrieval code must be provided");

        bytes32 retrievalCodeSecure = createRetrievalCodeSecure(retrievalCode, msg.sender);

        require(payments[retrievalCodeSecure].expiresTimestamp >=  block.timestamp, "Payment expired");
        uint payout = payments[retrievalCodeSecure].amount;

        require(payout > 0, "Retrieval code does not exist or has been used");

        payments[retrievalCodeSecure].amount = 0;
        emit LogWithdrawn(msg.sender, payout, retrievalCodeSecure);
        msg.sender.transfer(payout);

        return true;
    }

    /**
    * Allows original provider of deposit to reclaim it
    *
    * @param retrievalCodeSecure - a double keccak256 hash generated locally using two string parts and the target address
    *
    * @return true on success
    */
    function reclaim(bytes32 retrievalCodeSecure) beyondEndOfLifeOrOnlyIfRunning public returns (bool success){
        require(payments[retrievalCodeSecure].sender == msg.sender, "Sender must match the record in the retrieval code.");
        require(payments[retrievalCodeSecure].expiresTimestamp < block.timestamp, "Expiry Times not reached.");

        uint payout = payments[retrievalCodeSecure].amount;

        require(payout > 0, "Retrieval code does not exist or has been used");

        payments[retrievalCodeSecure].amount = 0;

        emit LogDepositReclaimed(msg.sender, payout, retrievalCodeSecure);
        msg.sender.transfer(payout);

        return true;
    }

    /**
     * Extend the expiry time of a payment by the sender
     *
     * @param retrievalCodeSecure - a double keccak256 hash generated locally using two string parts and the target address
     * @param extensionSeconds - seconds to add to the original timestamp
     *
     * @return true on success
     */
    function expireTimeExtend(bytes32 retrievalCodeSecure, uint extensionSeconds) onlyIfRunning public returns (bool success) {
        require(payments[retrievalCodeSecure].sender == msg.sender, "Sender must match the record in the retrieval code.");

        // I hope this saves gas
        uint expiresTimestamp = payments[retrievalCodeSecure].expiresTimestamp.add(extensionSeconds);

        require(expiresTimestamp <= block.timestamp.add(expiryLimit), "Expiry Timestamp too far in the future");

        emit LogTimestampExtended(msg.sender, expiresTimestamp, retrievalCodeSecure);
        payments[retrievalCodeSecure].expiresTimestamp = expiresTimestamp;

        return true;
    }
    /**
     * Shorten the expiry time of a payment by the exchange
     *e
     * @param retrievalCode  keccak256 hash generated locally and provided by the sender
     * @param shortenSeconds - seconds to subtract to the original timestamp
     *
     * @return true on success
     */
    function expireTimeShorten(bytes32 retrievalCode, uint shortenSeconds) onlyIfRunning public returns (bool success) {
        bytes32 retrievalCodeSecure = createRetrievalCodeSecure(retrievalCode, msg.sender);

        // I hope this saves gas
        uint expiresTimestamp = payments[retrievalCodeSecure].expiresTimestamp;

        require(expiresTimestamp > 0, "Payment does not exist");
        require(expiresTimestamp > block.timestamp, "Payment expired");

        expiresTimestamp = expiresTimestamp.sub(shortenSeconds);

        require(expiresTimestamp >= block.timestamp, "Cannot be shortened beyond now");

        emit LogTimestampShortend(msg.sender, expiresTimestamp, retrievalCodeSecure);
        payments[retrievalCodeSecure].expiresTimestamp = expiresTimestamp;

        return true;
    }
}
